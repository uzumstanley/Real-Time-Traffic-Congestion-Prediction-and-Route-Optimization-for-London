# -*- coding: utf-8 -*-
"""river_pier_network_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-gkwfD0Xk5BLx8PLg8pA0X80DKDZ-PIH
"""

import pandas as pd
import folium
from pyproj import Transformer

# Load data
df = pd.read_csv("/content/drive/MyDrive/APPLICATION/TfL_Traffic_Data/River_Piers.csv")

# Coordinate transformation (OSGB36 to WGS84)
transformer = Transformer.from_crs("EPSG:27700", "EPSG:4326")
lat, lon = transformer.transform(df["X"], df["Y"])
df["Latitude"] = lat
df["Longitude"] = lon

# Save cleaned data
df.to_csv("/content/drive/MyDrive/APPLICATION/TfL_Traffic_Data/Cleaned_River_Piers.csv", index=False)

df

# Create a Folium map centered on London
tfl_map = folium.Map(location=[51.5074, -0.1278], zoom_start=12)

# Add markers for each pier
for idx, row in df.iterrows():
    color = "blue" if row["STATUS"] == "Current" else "red"
    popup = folium.Popup(
        f"<b>{row['NAME']}</b><br>Status: {row['STATUS']}",
        max_width=250
    )
    folium.Marker(
        location=[row["Latitude"], row["Longitude"]],
        popup=popup,
        icon=folium.Icon(color=color)
    ).add_to(tfl_map)

# Save the map
tfl_map.save("/content/drive/MyDrive/APPLICATION/TfL_Traffic_Data/TfL_River_Piers_Map.html")

from sklearn.neighbors import NearestNeighbors
import numpy as np

# Calculate nearest neighbor distances for current piers
current_piers = df[df["STATUS"] == "Current"]
coords = current_piers[["Latitude", "Longitude"]].values

nbrs = NearestNeighbors(n_neighbors=2).fit(coords)
distances, _ = nbrs.kneighbors(coords)
avg_distance = np.mean(distances[:, 1]) * 111  # Convert degrees to km (~111 km/degree)
print(f"Average distance between piers: {avg_distance:.2f} km")

# Identify gaps (areas with >2km between piers)
gaps = current_piers[distances[:, 1] * 111 > 2]
print("Potential gaps at:", gaps["NAME"].tolist())

# Pseudo-code for network analysis (use NetworkX or OSMnx)
import networkx as nx

# Create a graph of piers
G = nx.Graph()
for _, row in df.iterrows():
    G.add_node(row["NAME"], pos=(row["Latitude"], row["Longitude"]))

# Add edges (hypothetical travel times)
for i in range(len(df)):
    for j in range(i+1, len(df)):
        node1 = df.iloc[i]["NAME"]
        node2 = df.iloc[j]["NAME"]
        distance = np.hypot(
            df.iloc[i]["Latitude"] - df.iloc[j]["Latitude"],
            df.iloc[i]["Longitude"] - df.iloc[j]["Longitude"]
        )
        G.add_edge(node1, node2, weight=distance)

# Find shortest path (example)
shortest_path = nx.shortest_path(G, source="Greenland Pier", target="Canary Wharf Pier", weight="weight")
print("Shortest path:", shortest_path)

